# -*- coding: utf-8 -*-
"""Exploratory Data Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uhtXp3q9uPDb0h3iJ4nPYMaaErdi3I_7

# 1: Importing Libraries
The below code imports libraries for data handling, math, and visualization in Python, including tools to work with tables, numbers, and graphs. It also adds tools for maps and spatial data. Finally, it hides any non-critical warning messages to keep the output clean.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sn
import geopandas as gpd
#to ignore warnings
import warnings
warnings.filterwarnings('ignore')

"""# 2: Loading the Dataset
The code loads data from a CSV file, handling special characters and skipping any rows with errors to avoid interruptions.
"""

data = pd.read_csv('data.csv', encoding='ISO-8859-1', on_bad_lines='skip')

"""# 3: Quick preview of the dataset
The "Quick Preview of the Dataset" provides a brief overview of the dataset's contents, highlighting its structure and key attributes. It helps users quickly understand the type of data they are working with, such as the number of rows, columns, and sample values.

## 3.1: Displaying the top 5 rows
"""

#This code displays the first few rows (usually 5) of the dataset, giving a quick preview of its contents and structure.
data.head()

"""## 3.2: Displaying the last 5 rows"""

#This code displays the last few rows (usually 5) of the dataset.
data.tail()

"""# 4: Summary of the dataset#
It provides a summary of the dataset, showing information about each column, including the column names, data types, and the number of non-missing values in each column. And also shows the number of unique values in each column of the dataset, helping identify distinct entries or categories in each field.

## 4.1: Basic information of the dataset
"""

data.info()

"""## 4.2: Checks for any missing values

"""

#This code checks for any missing values in the dataset and shows the total count of missing entries in each column.
data.isnull().sum()

"""# 5: Visualisation#
Data visualization is the graphical representation of information and data. By using visual elements like charts, graphs, maps, and other visual tools, data visualization provides a way to see and understand trends, outliers, and patterns in data. It simplifies complex datasets, enabling better insights and decision-making by making data more accessible, understandable, and actionable, especially for audiences who may not be data experts.

## 5.1: Distribution of Signal Strength for various places
This analysis visualizes the distribution of signal strength across different locations for various manufacturers and service providers, highlighting performance variations.
"""

#Histogram of Signal Strength
for col in [col for col in data.columns if 'Signal Strength' in col]:
    plt.figure(figsize=(8, 4))
    plt.hist(data[col].dropna(), bins=20, color='skyblue', edgecolor='black')
    plt.title(f'Distribution of {col}')
    plt.xlabel('Signal Strength (dBm)')
    plt.ylabel('Frequency')

    # Rotate x-axis labels and adjust tick frequency
    plt.xticks(rotation=90)
    # Adjust layout to prevent overlapping
    plt.tight_layout()
    plt.show()

"""## 5.2 Distribution of Primary Mobile Service Providers
This pie chart illustrates the distribution of primary mobile service providers among users, with each slice representing a provider's share. The percentages offer a quick view of provider popularity, enhanced by separated slices and distinct colors for clarity.
"""

#Pie Chart of Service Providers
plt.figure(figsize=(8, 8))

# Customize the pie chart for a cleaner look
data['Service Provider 1'].value_counts().plot(
    kind='pie',
    autopct='%1.1f%%',
    startangle=140,
    colors=['#ff9999', '#66b3ff', '#99ff99', '#ffcc99'],
    explode=[0.1] * data['Service Provider 1'].nunique()  # Slightly separates each slice
)

plt.title('Service Provider Distribution', fontsize=14)
plt.ylabel('')  # Removes the y-label
plt.axis('equal')  # Ensures the pie chart is a circle rather than an oval
plt.tight_layout()  # Adjusts layout for a cleaner appearance

plt.show()

"""## 5.3: Signal Strength vs ASU
Visualize the relationship between ASU and signal strength using a scatter plot to identify trends and correlations.
"""

#Scatter Plot of Signal Strength vs ASU
import seaborn as sns
signal_strength_column = 'Signal Strength for Place 1'
asu_column = 'ASU for place 1'

plt.figure(figsize=(10, 6))
sns.scatterplot(x=signal_strength_column, y=asu_column, data=data, color='purple')
plt.title('Signal Strength for Place 1 vs ASU for Place 1')
plt.xlabel('Signal Strength (dBm)')
plt.ylabel('ASU')
plt.xticks(rotation=90)
plt.show()

"""## 5.4: Count of Users by Mobile Manufacturer
This bar chart displays the count of users for each mobile manufacturer, highlighting which brands are most popular among the dataset's users. The visualization offers a quick comparison of user preferences by manufacturer.
"""

#Bar Chart: Count of Users by Mobile Manufacturer
plt.figure(figsize=(10, 6))
sns.countplot(y='Manufacturer/Parent Company of your Mobile', data=data, order=data['Manufacturer/Parent Company of your Mobile'].value_counts().index)
plt.title('Count of Users by Mobile Manufacturer')
plt.xlabel('Count')
plt.ylabel('Mobile Manufacturer')
plt.show()

"""## 5.5: Signal Strength Across Different Places for a Specific User
This line chart shows the signal strength measured at various places for a specific user, illustrating how signal quality fluctuates across locations. It allows for easy tracking of connection reliability for that user's mobile device.
"""

def plot_signal_strength_for_user():
  """
  Plots a line chart showing signal strength across different places for a specific user.
  """
  user_name = input("Enter the name of the user: ")

  # Assuming 'Name' is the correct column name for user names:
  if user_name in data['Name'].values:  # Changed 'Your Name' to 'Name'
    user_data = data[data['Name'] == user_name]  # Changed 'Your Name' to 'Name'

    place_columns = [col for col in data.columns if 'Signal Strength for Place' in col]
    place_names = [col.replace('Signal Strength for Place ', '') for col in place_columns]

    signal_strengths = user_data[place_columns].values.flatten().tolist()

    plt.figure(figsize=(12, 6))
    plt.plot(place_names, signal_strengths, marker='o')
    plt.xlabel("Place")
    plt.ylabel("Signal Strength (dBm)")
    plt.title(f"Signal Strength Across Different Places for {user_name}")
    plt.grid(True)
    plt.xticks(rotation=45, ha="right")
    plt.tight_layout()
    plt.show()
  else:
    print("User not found in the dataset. Please check the name and try again.")

# Call the function to generate the plot
plot_signal_strength_for_user()

"""## 5.6: Correlation Between ASU Values Across Places

The correlation between ASU values across places examines how the ASU values for different locations are related to each other. This analysis helps identify patterns or trends in the ASU data across various places, visualized using a heatmap to show the strength and direction of the correlations.
"""

#Heatmap: Correlation Between ASU Values Across Places
#Select ASU columns
asu_cols = [col for col in data.columns if 'ASU for place' in col]

# Extract numeric part from ASU values and convert to float
asu_data = data[asu_cols].apply(lambda x: pd.to_numeric(x.str.extract(r'(\d+)')[0], errors='coerce'))

# Drop rows with all NaN values
asu_data = asu_data.dropna(how='all')

# Calculate the correlation matrix
correlation_matrix = asu_data.corr()

# Plot the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Correlation Matrix of ASU Values Across Places')
plt.show()

"""## 5.7: Count of Signal Strength Levels by Service Provider
This code analyzes the signal strength data from different service providers and creates a stacked bar chart to show the count of different signal strength categories (Weak, Moderate, and Strong) for each service provider.


"""

#Stacked Bar Chart: Count of Signal Strength Levels by Service Provider
# Convert positive Signal Strength values to negative
signal_cols = [col for col in data.columns if 'Signal Strength for Place' in col]
# Convert the signal strength columns to numeric, handling errors
data[signal_cols] = data[signal_cols].apply(pd.to_numeric, errors='coerce')
data[signal_cols] = data[signal_cols].applymap(lambda x: -abs(x) if x > 0 else x)
def categorize_signal(signal):
    signal = float(signal)
    if signal <= -110:
        return 'Weak'
    elif -110 < signal <= -90:
        return 'Moderate'
    else:
        return 'Strong'

data['Signal Category'] = data['Signal Strength for Place 1'].apply(categorize_signal)

signal_counts = data.groupby(['Service Provider 1', 'Signal Category']).size().unstack(fill_value=0)
signal_counts.plot(kind='bar', stacked=True, color=['#ff9999','#66b3ff','#99ff99'])
plt.title('Signal Strength Categories by Service Provider')
plt.xlabel('Service Provider')
plt.ylabel('Count')
plt.legend(title='Signal Strength')
plt.show()

"""## 5.8: Average Signal Strength by Manufacturer and Service Provider
This code creates a heatmap that shows the average signal strength for different mobile manufacturers and service providers
"""

# Calculate average signal strength for each manufacturer and service provider
average_signal_by_manufacturer_provider = data.groupby(['Manufacturer/Parent Company of your Mobile', 'Service Provider 1'])['Signal Strength for Place 1'].mean().unstack()

# Create a heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(average_signal_by_manufacturer_provider, annot=True, cmap='viridis', fmt=".2f")
plt.title('Average Signal Strength by Manufacturer and Service Provider')
plt.xlabel('Service Provider')
plt.ylabel('Mobile Manufacturer')
plt.show()

"""## 5.9 Signal Strength Analysis for Selected Service Provider
This code analyzes signal strength for a chosen mobile service provider, highlighting locations with the best and worst signals. It displays a bar chart with gradient colors for easy comparison across locations.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
data = pd.read_csv('data.csv', encoding='ISO-8859-1', on_bad_lines='skip')  # Replace with your actual file path

def find_best_and_worst_signal_strength(data, provider_name):
    # Normalize the service provider name for case insensitivity
    provider_name = provider_name.lower()

    # Check if each provider column matches the input name, filling NaNs as needed
    service_provider_1 = data['Service Provider 1'].str.lower().fillna('')
    service_provider_2 = data['Service Provider 2'].str.lower().fillna('')

    # Filter data to include only rows with the specified service provider (case insensitive match)
    filtered_data = data[(service_provider_1 == provider_name) | (service_provider_2 == provider_name)]

    if filtered_data.empty:
        print(f"No data found for the service provider '{provider_name}'")
        return

    # Collect signal strengths for all places
    signal_columns = [col for col in data.columns if 'Signal Strength for Place' in col]
    signals = filtered_data[signal_columns].apply(pd.to_numeric, errors='coerce')

    # Calculate best and worst places for signal strength
    best_place = signals.idxmax(axis=1).values[0]  # Column (Place) with highest signal strength
    worst_place = signals.idxmin(axis=1).values[0] # Column (Place) with lowest signal strength
    best_value = signals.max(axis=1).values[0]
    worst_value = signals.min(axis=1).values[0]

    # Output results
    print(f"For service provider '{provider_name.title()}':")
    print(f" - Best signal strength is {best_value} at {best_place}")
    print(f" - Worst signal strength is {worst_value} at {worst_place}")

    # Prepare data for plotting
    signal_values = signals.iloc[0].sort_values()
    places = signal_values.index

    # Plot the signal strengths for each place with a gradient color scheme
    plt.figure(figsize=(14, 7))
    color_map = sns.color_palette("coolwarm", len(signal_values))
    bars = plt.barh(places, signal_values, color=color_map, edgecolor="black")

    # Highlight the best and worst signal bars
    bars[places.get_loc(best_place)].set_color("green")
    bars[places.get_loc(worst_place)].set_color("red")

    # Add annotations
    for bar, value in zip(bars, signal_values):
        plt.text(
            value,
            bar.get_y() + bar.get_height() / 2,
            f"{value:.1f}",
            ha="left",
            va="center",
            color="black",
            fontsize=10,
            fontweight="bold"
        )

    # Chart formatting
    plt.title(f"Signal Strength at Different Places for '{provider_name.title()}'", fontsize=16, fontweight="bold")
    plt.xlabel("Signal Strength", fontsize=14)
    plt.ylabel("Places", fontsize=14)
    plt.grid(axis='x', linestyle='--', alpha=0.7)
    plt.gca().invert_yaxis()  # Invert y-axis to have the best signal at the top

    # Show the plot
    plt.show()

# Get user input and call the function
provider_name = input("Enter the service provider name: ")
find_best_and_worst_signal_strength(data, provider_name)

"""## 5.10: Interactive Map of Signal Strength and ASU by Location
It generates an interactive map based on a user-specified location, displaying signal strength and ASU levels. It extracts latitude and longitude from geolocation data and uses Plotly to create a map visualization for easy location-based analysis.
"""

#displaying info according to the place
import plotly.express as px
import re
import pandas as pd


# Function to convert DMS to decimal degrees
def dms_to_dd(dms_str):  # Define the dms_to_dd function inside this cell
    dms_match = re.match(r"(\d+)[°'](\d+)'(\d+)\"", dms_str)
    if dms_match:
        degrees = int(dms_match.group(1))
        minutes = int(dms_match.group(2))
        seconds = int(dms_match.group(3))
        return degrees + (minutes / 60) + (seconds / 3600)
    else:
        return None
# Get place input from the user
place_number = input("Enter the place number to plot (e.g., 1, 2, 3): ")

# Construct column names based on user input
geolocation_col = f"Geolocation of place {place_number}"
signal_strength_col = f"Signal Strength for Place {place_number}"
asu_col = f"ASU for place {place_number}"

# Extract latitude and longitude from the specified geolocation column
data['latitude'] = data[geolocation_col].apply(lambda x: dms_to_dd(x.split()[0]) if len(x.split()) > 0 else None)
data['longitude'] = data[geolocation_col].apply(lambda x: dms_to_dd(x.split()[1]) if len(x.split()) > 1 else None)

# Convert ASU and Signal Strength columns to numeric
data[asu_col] = data[asu_col].astype(str).str.replace('[^0-9.]', '', regex=True)
data[asu_col] = pd.to_numeric(data[asu_col], errors='coerce').fillna(0)

data[signal_strength_col] = data[signal_strength_col].astype(str).str.replace('[^0-9.-]', '', regex=True)
data[signal_strength_col] = pd.to_numeric(data[signal_strength_col], errors='coerce').fillna(0)

# Drop rows with missing or invalid coordinates
data = data.dropna(subset=['latitude', 'longitude'])

# Create a scatter_mapbox plot
fig = px.scatter_mapbox(
    data,
    lat="latitude",
    lon="longitude",
    color=signal_strength_col,  # Use the user-specified signal strength column
    size=asu_col,  # Use the user-specified ASU column
    hover_data=["Service Provider 1", "Manufacturer/Parent Company of your Mobile"],
    zoom=10,
    height=600,
    width=800
)

fig.update_layout(mapbox_style="open-street-map")
fig.update_layout(margin={"r": 0, "t": 0, "l": 0, "b": 0})
fig.show()

"""# 6: Summary
The exploratory data analysis (EDA) focuses on analyzing a dataset related to signal strength and mobile service providers. The analysis involves loading the dataset, checking for missing values, and visualizing various aspects of the data to understand trends and relationships. Key visualizations include distributions of signal strength, service provider popularity, correlations between ASU values, and comparisons of signal strength across different mobile manufacturers and service providers.

# 7: Key Findings
**Distribution of Signal Strength:** The histograms reveal the frequency distribution of signal strength across different locations, indicating variations in performance among various manufacturers and service providers.

**Service Provider Popularity:** A pie chart illustrates the distribution of primary mobile service providers, highlighting the most popular providers among users.

**Signal Strength vs. ASU**: A scatter plot shows the relationship between ASU and signal strength, which helps identify trends and correlations in the dataset.

**User Preferences:** A bar chart displays the count of users by mobile manufacturer, indicating which brands are most favored among the dataset's users.

**Signal Strength Variability:** The line chart highlights how signal strength fluctuates across different places for specific users, showcasing connection reliability.

**Correlation Analysis:** A heatmap reveals the correlation between ASU values across different places, helping to identify patterns in the ASU data.

**Signal Strength Categories:** A stacked bar chart categorizes signal strength levels (Weak, Moderate, Strong) by service provider, providing insights into the performance of different providers.

**Average Signal Strength: **A heatmap indicates the average signal strength by manufacturer and service provider, allowing for comparisons of performance across different brands.

**Best and Worst Signal Strength:** The analysis identifies locations with the best and worst signal strengths for selected service providers, aiding in understanding service quality.

Interactive Mapping: An interactive map visualizes signal strength and ASU levels by location, enhancing location-based analysis.

# 8: Conclusion
The exploratory data analysis provides valuable insights into signal strength variations across different locations, service providers, and mobile manufacturers. The visualizations effectively communicate trends and patterns in the dataset, allowing stakeholders to identify areas for improvement in service quality and user experience. The analysis can inform decision-making for mobile service providers, helping them enhance their network performance and cater to user preferences. Overall, the findings underscore the importance of data-driven insights in the telecommunications industry, particularly in optimizing service delivery and user satisfaction.
"""